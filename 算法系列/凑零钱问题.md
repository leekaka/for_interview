# 凑零钱问题

[322. Coin Change](https://leetcode.com/problems/coin-change/)

You are given coins of different denominations and a total amount of money *amount*. Write a function to compute the **fewest number** of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.

You may assume that you have an infinite number of each kind of coin.

**Example**

```python
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
    
Constraints:
1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104
```

简单描述就是，首先给定一个总数`amount`，然后有几种硬币，币值比如是`1，2，5`，且每种硬币数量不限，那么**最少**多少枚硬币可以凑出总数`amount`，如果凑不出，则返回-1，很容易想到的就是假设币值都是1，则最大应该是`amount`块硬币。

**1、暴力递归**

观察题目，首先，存在一个**最少** ，意味着需要一个**最优解**。

其次，要凑出总数`n`的最少枚硬币，和凑出总数`n-coin`(硬币值)的是一样的问题，即存在子问题，且有**重复子问题**。

根据example进一步分析，想要凑整数为11，可以先凑出总数为10或者为9或者为6，（这样只差一块硬币），我们很容易得出这样一个公式：

$$
f(11) = min(f(10)+f(9)+f(6)) + 1
$$
+1 表示只需要再来一块硬币即可。

这也就是在上文 [斐波那契数列](./斐波那契数列.md) 中提到的状态转移方程。

上述寥寥几行，就把一个动态规划问题的基本点都描述出来了.

- 1、首先是有重复子问题；
- 2、其次需要最优规划；
- 3、列出状态转移方程。

那如何递归呢？想着把所有的coins遍历一次，减一个找到最小的就行，先看我的初始代码：

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        int res = amount + 1;
        for (int i = 0; i < coins.size(); i++) {
            if (coinChange(coins, amount-coins[i]) == -1) continue;
            res = min(res, coinChange(coins, amount-coins[i]) + 1);
        }
        return res == amount + 1? -1 : res; 
    }
};
```

很遗憾超时了···，明显这是因为递归过程中存在超多的重复子问题，如图所示：

<img src="D:\Mygithub\for_interview\pics\DynamicPlanning\coins\1.jpg" style="zoom:67%;" />

根据经验，我们开始优化。

**2、带备忘录的递归**

用备忘录记住那些曾经计算过的子问题，进行算法优化，我写出了如下代码：

```cpp
class Solution {
public:
    int helper(map<int,int>&memo_map, vector<int>& coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        if (memo_map.find(amount) != memo_map.end()) {return memo_map[amount];}
        int min_res = amount + 1;
        for (int i = 0; i < coins.size(); i++) {
            int subproblem = helper(memo_map, coins, amount-coins[i]);
            if (subproblem == -1) { continue;} // 子问题无解
            min_res = min(min_res, subproblem + 1);
        }
        memo_map[amount] = min_res > amount? -1 : min_res;
        return  memo_map[amount];
    }
    
    int coinChange(vector<int>& coins, int amount) {
        map<int,int>memo_map;
        return helper(memo_map, coins, amount);   
    }
};
```

很遗憾还是超时，也就是说尽管我们去减去了很多不必要计算的分支，但是因为本身amount和coins值相差很多，每次比较都需要去递归找下一个子问题，下一步，我们就只能采取杀技了。从下往上把每个子问题都预先列出来，不必要再去从上到下的搜索即可。

**3、dp 数组的迭代解法**

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp (amount+1, amount+1);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(auto c : coins){
                if (i - c < 0) continue; // 不存在
                dp[i] = min(dp[i], dp[i-c] + 1);
            }
        }
        return dp[amount] == amount + 1? -1: dp[amount];
    }
    
    // 下面这个就是不把dp[i]全部计算完，只计算大于硬币值的部分
	int coinChange(vector<int>& coins, int amount) {
		vector<int> dp(amount+1,amount+1);
		dp[0]=0;
		for(auto c : coins){
			for(int i = c; i <= amount; i++){
				dp[i] = min(dp[i], dp[i - c] + 1);
			}
		}
		return dp[amount] >= amount + 1? -1 : dp[amount];

	}
};
```

![](..\pics\DynamicPlanning\coins\2.jpg)

### 总结

凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。

本来我以为通过「备忘录」或者「dp table」的方法来优化递归树，这两种方法本质上一样，一个是自顶向下，另一个自底向上的不同，但是通过实践发现，备忘录的递归方式可能还是有点问题。

从该题我们也总结出几个经验：

**1、先确定「状态」**，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 `amount`。

**2、然后确定 `helper` 函数的定义**：当前的目标金额是 `n`，至少需要 `helper(n)` 个硬币凑出该金额。

**3、最后确定「选择」并择优**，也就是对于每个状态，可以做出什么选择改变当前状态。

